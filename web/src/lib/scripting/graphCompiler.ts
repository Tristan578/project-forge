import type {
  VisualScriptGraph,
  VisualScriptNode,
  VisualScriptEdge,
  CompileResult,
  CompileError,
  CompileWarning,
} from './visualScriptTypes';

interface EdgeMap {
  byTarget: Map<string, VisualScriptEdge[]>;
  bySource: Map<string, VisualScriptEdge[]>;
}

/**
 * Compiles a visual script graph into executable TypeScript code.
 */
export function compileGraph(graph: VisualScriptGraph): CompileResult {
  const errors: CompileError[] = [];
  const warnings: CompileWarning[] = [];
  const lines: string[] = ['// Generated by Visual Script Compiler'];

  // Build node map and edge maps
  const nodeMap = new Map(graph.nodes.map(n => [n.id, n]));
  const edgeMap = buildEdgeMaps(graph.edges);

  // Find event nodes
  const eventNodes = graph.nodes.filter(n =>
    ['OnStart', 'OnUpdate', 'OnCollisionEnter', 'OnCollisionExit',
     'OnTriggerEnter', 'OnTriggerExit', 'OnKeyPress', 'OnTimer'].includes(n.type)
  );

  if (eventNodes.length === 0) {
    warnings.push({ nodeId: '', message: 'No event nodes found â€” script will do nothing' });
  }

  // Check for disconnected nodes
  checkDisconnectedNodes(graph.nodes, graph.edges, warnings);

  // Generate state variables
  const stateVars = generateStateVariables(graph.nodes);
  if (stateVars.length > 0) {
    lines.push('', '// State variables');
    lines.push(...stateVars);
  }

  // Compile each event handler
  const compiler = new GraphCompiler(nodeMap, edgeMap, errors, warnings);

  for (const eventNode of eventNodes) {
    const handler = compiler.compileEventHandler(eventNode);
    if (handler) {
      lines.push('', handler);
    }
  }

  return {
    success: errors.length === 0,
    code: lines.join('\n'),
    errors,
    warnings,
  };
}

function buildEdgeMaps(edges: VisualScriptEdge[]): EdgeMap {
  const byTarget = new Map<string, VisualScriptEdge[]>();
  const bySource = new Map<string, VisualScriptEdge[]>();

  for (const edge of edges) {
    // Group data edges by target
    const targetKey = `${edge.target}:${edge.targetHandle}`;
    if (!byTarget.has(targetKey)) byTarget.set(targetKey, []);
    byTarget.get(targetKey)!.push(edge);

    // Group exec edges by source
    const sourceKey = `${edge.source}:${edge.sourceHandle}`;
    if (!bySource.has(sourceKey)) bySource.set(sourceKey, []);
    bySource.get(sourceKey)!.push(edge);
  }

  return { byTarget, bySource };
}

function checkDisconnectedNodes(
  nodes: VisualScriptNode[],
  edges: VisualScriptEdge[],
  warnings: CompileWarning[]
): void {
  const connectedNodeIds = new Set<string>();
  for (const edge of edges) {
    connectedNodeIds.add(edge.source);
    connectedNodeIds.add(edge.target);
  }

  for (const node of nodes) {
    if (!connectedNodeIds.has(node.id) && !['OnStart', 'OnUpdate'].includes(node.type)) {
      warnings.push({ nodeId: node.id, message: `Node "${node.type}" is disconnected` });
    }
  }
}

function generateStateVariables(nodes: VisualScriptNode[]): string[] {
  const vars: string[] = [];
  const timerNodes = nodes.filter(n => n.type === 'OnTimer');

  for (const node of timerNodes) {
    vars.push(`let _timer_${node.id}_elapsed = 0;`);
  }

  return vars;
}

class GraphCompiler {
  constructor(
    private nodeMap: Map<string, VisualScriptNode>,
    private edgeMap: EdgeMap,
    private errors: CompileError[],
    private warnings: CompileWarning[]
  ) {}

  compileEventHandler(eventNode: VisualScriptNode): string | null {
    switch (eventNode.type) {
      case 'OnStart':
        return this.compileOnStart(eventNode);
      case 'OnUpdate':
        return this.compileOnUpdate(eventNode);
      case 'OnCollisionEnter':
        return this.compileCollisionEvent(eventNode, 'onCollisionEnter');
      case 'OnCollisionExit':
        return this.compileCollisionEvent(eventNode, 'onCollisionExit');
      case 'OnTriggerEnter':
        return this.compileCollisionEvent(eventNode, 'onTriggerEnter');
      case 'OnTriggerExit':
        return this.compileCollisionEvent(eventNode, 'onTriggerExit');
      case 'OnKeyPress':
        return this.compileKeyPress(eventNode);
      case 'OnTimer':
        return this.compileTimer(eventNode);
      default:
        this.warnings.push({ nodeId: eventNode.id, message: `Unknown event type: ${eventNode.type}` });
        return null;
    }
  }

  private compileOnStart(eventNode: VisualScriptNode): string {
    const body = this.compileExecChain(eventNode.id, 'exec_out', '  ');
    return `function onStart() {\n${body}\n}`;
  }

  private compileOnUpdate(eventNode: VisualScriptNode): string {
    const body = this.compileExecChain(eventNode.id, 'exec_out', '  ');
    return `function onUpdate(dt: number) {\n${body}\n}`;
  }

  private compileCollisionEvent(eventNode: VisualScriptNode, eventName: string): string {
    const entityId = this.resolveInput(eventNode.id, 'entity', eventNode);
    const body = this.compileExecChain(eventNode.id, 'exec_out', '    ');
    return `forge.physics.${eventName}(${entityId}, (otherEntityId) => {\n${body}\n});`;
  }

  private compileKeyPress(eventNode: VisualScriptNode): string {
    const key = this.resolveInput(eventNode.id, 'key', eventNode);
    const body = this.compileExecChain(eventNode.id, 'exec_out', '    ');
    return `// In onUpdate:\n  if (forge.input.justPressed(${key})) {\n${body}\n  }`;
  }

  private compileTimer(eventNode: VisualScriptNode): string {
    const interval = this.resolveInput(eventNode.id, 'interval', eventNode);
    const body = this.compileExecChain(eventNode.id, 'exec_out', '    ');
    return `// In onUpdate:\n  _timer_${eventNode.id}_elapsed += dt;\n  if (_timer_${eventNode.id}_elapsed >= ${interval}) {\n    _timer_${eventNode.id}_elapsed = 0;\n${body}\n  }`;
  }

  private compileExecChain(startNodeId: string, startHandle: string, indent: string): string {
    const edges = this.edgeMap.bySource.get(`${startNodeId}:${startHandle}`);
    if (!edges || edges.length === 0) return '';

    const lines: string[] = [];
    for (const edge of edges) {
      const node = this.nodeMap.get(edge.target);
      if (!node) continue;

      const statement = this.compileExecNode(node, indent);
      if (statement) {
        lines.push(statement);
      }
    }
    return lines.join('\n');
  }

  private compileExecNode(node: VisualScriptNode, indent: string): string | null {
    switch (node.type) {
      case 'SetPosition': {
        const entity = this.resolveInput(node.id, 'entity', node);
        const pos = this.resolveInput(node.id, 'position', node);
        const next = this.compileExecChain(node.id, 'exec_out', indent);
        return `${indent}forge.setPosition(${entity}, ${pos}[0], ${pos}[1], ${pos}[2]);${next ? '\n' + next : ''}`;
      }

      case 'Translate': {
        const entity = this.resolveInput(node.id, 'entity', node);
        const dx = this.resolveInput(node.id, 'dx', node);
        const dy = this.resolveInput(node.id, 'dy', node);
        const dz = this.resolveInput(node.id, 'dz', node);
        const next = this.compileExecChain(node.id, 'exec_out', indent);
        return `${indent}forge.translate(${entity}, ${dx}, ${dy}, ${dz});${next ? '\n' + next : ''}`;
      }

      case 'ApplyForce': {
        const entity = this.resolveInput(node.id, 'entity', node);
        const fx = this.resolveInput(node.id, 'fx', node);
        const fy = this.resolveInput(node.id, 'fy', node);
        const fz = this.resolveInput(node.id, 'fz', node);
        const next = this.compileExecChain(node.id, 'exec_out', indent);
        return `${indent}forge.physics.applyForce(${entity}, ${fx}, ${fy}, ${fz});${next ? '\n' + next : ''}`;
      }

      case 'ApplyImpulse': {
        const entity = this.resolveInput(node.id, 'entity', node);
        const fx = this.resolveInput(node.id, 'fx', node);
        const fy = this.resolveInput(node.id, 'fy', node);
        const fz = this.resolveInput(node.id, 'fz', node);
        const next = this.compileExecChain(node.id, 'exec_out', indent);
        return `${indent}forge.physics.applyImpulse(${entity}, ${fx}, ${fy}, ${fz});${next ? '\n' + next : ''}`;
      }

      case 'Branch': {
        const condition = this.resolveInput(node.id, 'condition', node);
        const trueBody = this.compileExecChain(node.id, 'exec_true', indent + '  ');
        const falseBody = this.compileExecChain(node.id, 'exec_false', indent + '  ');
        let code = `${indent}if (${condition}) {\n`;
        if (trueBody) code += trueBody + '\n';
        code += `${indent}}`;
        if (falseBody) {
          code += ` else {\n${falseBody}\n${indent}}`;
        }
        return code;
      }

      case 'ForLoop': {
        const start = this.resolveInput(node.id, 'start', node);
        const end = this.resolveInput(node.id, 'end', node);
        const body = this.compileExecChain(node.id, 'exec_body', indent + '  ');
        const next = this.compileExecChain(node.id, 'exec_out', indent);
        let code = `${indent}for (let i = ${start}; i < ${end}; i++) {\n`;
        if (body) code += body + '\n';
        code += `${indent}}`;
        if (next) code += '\n' + next;
        return code;
      }

      case 'SetVariable': {
        const key = this.resolveInput(node.id, 'key', node);
        const value = this.resolveInput(node.id, 'value', node);
        const next = this.compileExecChain(node.id, 'exec_out', indent);
        return `${indent}forge.state.set(${key}, ${value});${next ? '\n' + next : ''}`;
      }

      case 'SpawnEntity': {
        const type = this.resolveInput(node.id, 'type', node);
        const name = this.resolveInput(node.id, 'name', node);
        const x = this.resolveInput(node.id, 'x', node);
        const y = this.resolveInput(node.id, 'y', node);
        const z = this.resolveInput(node.id, 'z', node);
        const next = this.compileExecChain(node.id, 'exec_out', indent);
        return `${indent}forge.spawn(${type}, { name: ${name}, position: [${x}, ${y}, ${z}] });${next ? '\n' + next : ''}`;
      }

      case 'PlaySound': {
        const entity = this.resolveInput(node.id, 'entity', node);
        const next = this.compileExecChain(node.id, 'exec_out', indent);
        return `${indent}forge.audio.play(${entity});${next ? '\n' + next : ''}`;
      }

      case 'ShowText': {
        const id = this.resolveInput(node.id, 'id', node);
        const text = this.resolveInput(node.id, 'text', node);
        const x = this.resolveInput(node.id, 'x', node);
        const y = this.resolveInput(node.id, 'y', node);
        const next = this.compileExecChain(node.id, 'exec_out', indent);
        return `${indent}forge.ui.showText(${id}, ${text}, ${x}, ${y});${next ? '\n' + next : ''}`;
      }

      default:
        this.warnings.push({ nodeId: node.id, message: `Unknown exec node type: ${node.type}` });
        return null;
    }
  }

  private compileDataNode(node: VisualScriptNode, _outputPort: string): string {
    switch (node.type) {
      case 'Add': {
        const a = this.resolveInput(node.id, 'a', node);
        const b = this.resolveInput(node.id, 'b', node);
        return `(${a} + ${b})`;
      }

      case 'Subtract': {
        const a = this.resolveInput(node.id, 'a', node);
        const b = this.resolveInput(node.id, 'b', node);
        return `(${a} - ${b})`;
      }

      case 'Multiply': {
        const a = this.resolveInput(node.id, 'a', node);
        const b = this.resolveInput(node.id, 'b', node);
        return `(${a} * ${b})`;
      }

      case 'Divide': {
        const a = this.resolveInput(node.id, 'a', node);
        const b = this.resolveInput(node.id, 'b', node);
        return `(${a} / ${b})`;
      }

      case 'GetPosition': {
        const entity = this.resolveInput(node.id, 'entity', node);
        return `(forge.getTransform(${entity})?.position || [0, 0, 0])`;
      }

      case 'IsPressed': {
        const action = this.resolveInput(node.id, 'action', node);
        return `forge.input.isPressed(${action})`;
      }

      case 'GetAxis': {
        const action = this.resolveInput(node.id, 'action', node);
        return `forge.input.getAxis(${action})`;
      }

      case 'MakeVec3': {
        const x = this.resolveInput(node.id, 'x', node);
        const y = this.resolveInput(node.id, 'y', node);
        const z = this.resolveInput(node.id, 'z', node);
        return `[${x}, ${y}, ${z}]`;
      }

      case 'Distance': {
        const a = this.resolveInput(node.id, 'a', node);
        const b = this.resolveInput(node.id, 'b', node);
        return `Math.sqrt(Math.pow(${a}[0]-${b}[0],2)+Math.pow(${a}[1]-${b}[1],2)+Math.pow(${a}[2]-${b}[2],2))`;
      }

      case 'GetVariable': {
        const key = this.resolveInput(node.id, 'key', node);
        return `forge.state.get(${key})`;
      }

      default:
        this.warnings.push({ nodeId: node.id, message: `Unknown data node type: ${node.type}` });
        return '0';
    }
  }

  private resolveInput(nodeId: string, portId: string, node: VisualScriptNode): string {
    const key = `${nodeId}:${portId}`;
    const incoming = this.edgeMap.byTarget.get(key);

    if (incoming && incoming.length > 0) {
      const srcEdge = incoming[0];
      const srcNode = this.nodeMap.get(srcEdge.source);
      if (srcNode) {
        return this.compileDataNode(srcNode, srcEdge.sourceHandle);
      }
    }

    // Use inline value from node data
    const val = node.data[portId];
    if (val !== undefined) return this.formatValue(val);

    return '0'; // fallback
  }

  private formatValue(val: unknown): string {
    if (typeof val === 'string') return JSON.stringify(val);
    if (typeof val === 'boolean') return val ? 'true' : 'false';
    if (typeof val === 'number') return String(val);
    if (Array.isArray(val)) return `[${val.join(', ')}]`;
    return String(val);
  }
}
