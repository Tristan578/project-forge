name: Auto-fix failed CI with Copilot

on:
  workflow_run:
    workflows: ["CI"]  # Must match your CI workflow name exactly
    types:
      - completed

permissions:
  contents: read
  issues: write

jobs:
  create-fix-issue:
    # Only run when CI fails on a PR branch (not default branch)
    if: >
      github.event.workflow_run.conclusion == 'failure' &&
      github.event.workflow_run.head_branch != github.event.repository.default_branch
    runs-on: ubuntu-latest
    steps:
      - name: Get failed workflow details
        id: workflow-info
        uses: actions/github-script@v7
        with:
          script: |
            const run = context.payload.workflow_run;

            let failureDetails = '';
            try {
              // Get failed jobs
              const jobsResponse = await github.rest.actions.listJobsForWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: run.id,
              });

              if (!jobsResponse || !jobsResponse.data || !Array.isArray(jobsResponse.data.jobs)) {
                throw new Error('Unexpected response structure from listJobsForWorkflowRun');
              }

              const failedJobs = jobsResponse.data.jobs.filter(j => j.conclusion === 'failure');

              if (failedJobs.length === 0) {
                failureDetails = 'No specific job failures were detected. The workflow may have been cancelled, timed out, or failed before any jobs were started.\n';
              } else {
                for (const job of failedJobs) {
                  failureDetails += `### ❌ ${job.name}\n`;

                  // Get job logs (step-level detail)
                  const failedSteps = job.steps?.filter(s => s.conclusion === 'failure') || [];
                  for (const step of failedSteps) {
                    failureDetails += `- **Step failed:** ${step.name}\n`;
                  }
                  failureDetails += `- [View logs](${job.html_url})\n\n`;
                }
              }
            } catch (error) {
              core.setFailed(`Failed to retrieve or process workflow jobs: ${error && error.message ? error.message : String(error)}`);
              console.error('Error while listing workflow jobs:', error);
              return;
            }

            const issueBody = `## CI Failure — Auto-generated for Copilot

**Branch:** \`${run.head_branch}\`
**Commit:** [\`${run.head_sha.substring(0, 7)}\`](${run.html_url})
**Workflow:** ${run.name}
**Run:** [#${run.run_number}](${run.html_url})

## Failed Jobs

${failureDetails}

## Instructions for Copilot

1. Check out branch \`${run.head_branch}\`
2. Read the CI workflow at \`.github/workflows/ci.yml\` to understand what checks run
3. Read the Copilot instructions at \`.github/instructions/*.instructions.md\` for project context
4. Analyze the failure(s) above and identify root cause
5. Fix the code to make CI pass
6. Run the relevant checks locally before committing:
   - For lint failures: \`cd web && npm ci && npx eslint --max-warnings 0\`
   - For typecheck failures: \`cd web && npm ci && npx tsc --noEmit\`
   - For web test failures: \`cd web && npm ci && npx vitest run\`
   - For MCP test failures: \`cd mcp-server && npm ci && npx vitest run\`
   - For WASM failures: \`cd engine && cargo build --target wasm32-unknown-unknown --release --features webgl2\`
   - For audit failures: \`cd web && npm audit --audit-level=high\` or \`cd mcp-server && npm audit --audit-level=high\`

**Important:** Follow the coding standards in \`.github/instructions/*.instructions.md\`. Do not weaken CI checks or add \`eslint-disable\` comments without justification.`;

            // Use GITHUB_OUTPUT file for safe multiline output
            const fs = require('fs');
            const setOutputSafe = (name, value) => {
              const delimiter = `EOF_${Math.random().toString(36).slice(2)}`;
              const outputLine = `${name}<<${delimiter}\n${value}\n${delimiter}\n`;
              fs.appendFileSync(process.env.GITHUB_OUTPUT, outputLine, { encoding: 'utf8' });
            };

            setOutputSafe('title', `fix(ci): auto-fix CI failure on \`${run.head_branch}\` (run #${run.run_number})`);
            setOutputSafe('body', issueBody);
            setOutputSafe('branch', run.head_branch);
            setOutputSafe('branch_label', `branch:${run.head_branch}`);

      - name: Create issue and assign to Copilot
        uses: actions/github-script@v7
        env:
          ISSUE_TITLE: ${{ steps.workflow-info.outputs.title }}
          ISSUE_BODY: ${{ steps.workflow-info.outputs.body }}
          BRANCH_NAME: ${{ steps.workflow-info.outputs.branch }}
          BRANCH_LABEL: ${{ steps.workflow-info.outputs.branch_label }}
        with:
          # Required secret:
          #   COPILOT_ASSIGN_PAT -> Personal Access Token (PAT) used to create and assign issues.
          # Minimum permissions:
          #   - For fine-grained PATs: repository permissions with "Issues: Read and write".
          #   - For classic PATs: "repo" scope (to allow listing, creating, labeling, and assigning issues).
          github-token: ${{ secrets.COPILOT_ASSIGN_PAT }}
          script: |
            const title = process.env.ISSUE_TITLE;
            const body = process.env.ISSUE_BODY;
            const branch = process.env.BRANCH_NAME;
            const branchLabel = process.env.BRANCH_LABEL;

            // Check if an open issue already exists for this branch
            // Strategy: First try to find by branch-specific label (most robust),
            // then fall back to exact title matching with backticks
            const existing = await github.paginate(
              github.rest.issues.listForRepo,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: 'copilot-autofix',
                per_page: 100,
              }
            );

            // Primary: Match by branch-specific label
            let duplicate = existing.find(i =>
              i.labels.some(label => label.name === branchLabel)
            );

            // Fallback: Match by exact branch name in backticks in title
            if (!duplicate) {
              duplicate = existing.find(i =>
                i.title.includes(\`\\\`${branch}\\\`\`)
              );
            }

            if (duplicate) {
              // Update existing issue instead of creating a new one
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: duplicate.number,
                body: `CI failed again. Updated failure details:\n\n${body}`,
              });
              console.log(`Updated existing issue #${duplicate.number}`);
              return;
            }

            // Create new issue
            // Note: The 'copilot' assignee must be a valid GitHub username with access to this repository
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['copilot-autofix', 'ci-failure', branchLabel],
              assignees: ['copilot'],  // Assigns to Copilot coding agent
            });

            console.log(`Created issue #${issue.data.number}: ${issue.data.html_url}`);
